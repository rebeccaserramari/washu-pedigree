# Scripts for analyzing variability within units in rDNA arrays

This folder contains Python helper scripts for analyzing multiple sequence alignments (MSAs) or rDNA assemblies in fasta format. 
These scripts assist with tasks like 
- trimming alignments
- computing per-column statistics
- identifying conserved or variable regions
- analyzing blocks of conservation
- analyzing conservation of G4 sequences from alignments

All scripts are written in Python and depend on **Biopython** and **pandas** (where noted).

---

## Scripts
Each script contains detailed documentation and usage instructions within the script files themselves.

### 1. `trim.py`
Remove leading and trailing alignment columns that aren't conserved. This produces an alignment starting and ending with fully aligned columns.

- **Features**: 
  - Detects the first and last alignment columns where **all sequences contain a real nucleotide** (A/C/G/T).
  - Removes all-gap columns at the beginning and end of the alignment.
  - Prints the kept coordinate range 

- **Notes**
  - Coordinates are **1-based**.

- **Arguments**
  - `<aligned_fasta>` : Input MSA in FASTA format.  
  - `<out_fasta>` : Output path for the trimmed alignment.

- **Dependencies**
  - Biopython

```bash
# Usage
python trim.py <aligned_fasta> <out_fasta>

# Example
python trim.py input_alignment.fasta trimmed_alignment.fasta
```

- **Output**:
  - Outputs a trimmed alignment in FASTA format `<out_fasta>`.
  - Statistical report to stdout.

### 2. `make_statistics.py`
Compute per-column nucleotide statistics from a multiple sequence alignment (MSA) and identify conserved columns (columns with 100% identity across all sequences).

- **Features**: 
  - Counts the occurrences of **A, C, G, T, and gaps** for each alignment column.
  - Detects **fully conserved columns** where all sequences share the same nucleotide.

- **Notes**
  - **Case-insensitive** analysis (handles both upper- and lowercase nucleotides).

- **Arguments**
  - `<aligned_fasta>` : Input MSA in FASTA format.  
  - `<stats_file_tsv>` : Output TSV file listing variable columns and counts of nucleotides/gaps.

- **Dependencies**
  - Biopython

```bash
# Usage
python make_statistics.py <aligned_fasta> <stats_file_tsv>

# Example
python make_statistics.py input_alignment.fasta variable_columns.tsv
```

- **Output**
    - TSV file with the following columns `position, a, c, g, t, gaps` listing only variable alignment columns.

### 3. `parse_alignment_by_blocks.py`
Segment a multiple sequence alignment (MSA) into **conserved** and **variable** blocks based on a conservation threshold.

- **Features**: 
  - Classifies each column as **conserved** or **variable** using a user-defined conservation threshold.
  - Conserved blocks contain columns where a single nucleotide dominates above the threshold.
  - Variable blocks report counts of **A, C, G, T** nucleotides.
  - Ignores gaps (`-`) when determining conservation. 

- **Notes**
  - Coordinates are **0-based and inclusive**.

- **Arguments**
  - `<alignment.fasta>` : Input MSA in FASTA format (trimmed MSA is recommended).  
  - `<output.tsv>` : Output TSV file listing conserved and variable blocks.  
  - `<conservation_threshold>` : Minimum fraction (0–1) required for a column to be considered conserved.

- **Dependencies**
  - Biopython

```bash
# Usage
python parse_alignment_by_blocks.py <alignment.fasta> <output.tsv> <conservation_threshold>

# Example
python parse_alignment_by_blocks.py input_alignment.fasta blocks.tsv 0.9
```

- **Output**
  - TSV file with columns `start, end, type, A_count, C_count, G_count, T_count`
  - **type** is either `conserved` or `variable`

### 4. `count_blocks_primary_bases.py`
Compute the **primary base composition** of variable blocks from a block annotation table generated by `parse_alignment_by_blocks.py`.

- **Features**: 
  - Processes variable blocks only.  
  - Determines the **smallest set of bases** (A, C, G, T) whose cumulative frequency is ≥ 0.75.  
  - Filters blocks by a **user-defined minimum block length**.

- **Arguments**
  - `<blocks.tsv>` : Input TSV file in format same sa output produced by `parse_alignment_by_blocks.py`. 
  - `<output.tsv>` : Output TSV file listing block lengths and primary bases.  
  - `<block_length_threshold>` : Minimum block length (inclusive) for a block to be reported.

- **Dependencies**
  - pandas

```bash
# Usage
python count_blocks_primary_bases.py <blocks.tsv> <output.tsv> <block_length_threshold>

# Example
python count_blocks_primary_bases.py blocks.tsv primary_bases.tsv 3
```

- **Output**
    - TSV file with columns: `length, primary_bases`

### 5. `g4_analysis.py`
Map G4 motif coordinates from a GFF file onto a multiple sequence alignment (MSA) and compute a **conservation score** for each G4 motif.

- **Features**: 
  - Translates GFF coordinates to aligned positions in the MSA (handles gaps).  
  - Extracts the aligned nucleotide sequence for each G4 region.  
  - Computes the fraction of fully conserved columns (100% identity) for each G4.

- **Arguments**
  - `<aligned_fasta>` : Alignment file (output from MSA tool) in FASTA format. Should **not be trimmed** to preserve positional offsets.  
  - `<g4_data_gff>` : GFF3 file containing predicted/found G4 features. Required fields: `seqid`, `start`, `end`, `score`, `attributes`.  
  - `<output_tsv>` : Output TSV file path

- **Dependencies**
  - Biopython  
  - pandas

- **Notes**
  - Coordinates in the GFF file are **1-based and inclusive**.
  - Use **full, non-trimmed** alignments to ensure correct mapping of G4 coordinates.

```bash
# Usage
python g4_analysis.py <aligned_fasta> <g4_data_gff> <output_tsv>

# Example
python g4_analysis.py rDNA_alignment.fasta g4_predictions.gff g4_conservation.tsv
```

- **Output**
  - TSV file <output_tsv> with columns `seqid, start, end, score, attributes, sequence_from_alignment, conserved(%)`



